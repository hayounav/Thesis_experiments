#!/usr/bin/bash

shopt -s extglob

trap myexit EXIT

myexit(){
    kill $(jobs -p) 2>/dev/null
}

# seed the generator in a reproduceable way.
# use a variable value (e.g., the pid variable $$) instead
# to get a different random sequence each run.
RANDOM=42

# be mindful of the tests generated by the random sequence
# on my machine (WSL2 Ubuntu 20.04) using this random seed,
# the following tests were invalid and needed to be regenerated with a different seed:
# - linearizable-8-250-21 (was a duplicate of linearizable-8-250-1)
# - non_linearizable-5-100-9 (was actually linearizable)
# - non_linearizable-6-50-1 (was actually linearizable)
# - non_linearizable-6-100-23 (was actually linearizable)
# - non_linearizable-8-25-2 (was actually linearizable)
# - non_linearizable-8-50-8 (was actually linearizable)
# - non_linearizable-10-25-19 (was actually linearizable)
# - non_linearizable-10-25-21 (was actually linearizable)

SPIN=spin
LOWE="./Lowe"
CC=gcc
FNAME=test.pml
TEST_DIR=Tests
RESULTS_DIR=Results
TABULATED_FILE=results.csv
V_PROC_COUNTS=(5 8 11 14 17 20)
V_HISTORY_SIZES=(100 250 500)
IV_PROC_COUNTS=(3 4 5 6 8 10)
IV_HISTORY_SIZES=(25 50 100)
HISTORIES_PER_COMBO=25
SCALA_TIMEOUT=600
SCALA_HEAP_SIZE=20G
PATTERN="
#define pi 0
#define pj 1

chan startUpdate = [0] of {byte, bit}
chan endUpdate = [0] of {byte, bit}
chan startScan = [0] of {byte}
chan endScan = [0] of {byte, bit, bit}

active proctype Main() {
    #include \"aaa\"
}

#include \"snap_conditions.pml\"
"

usage() {
cat <<EOF
Usage: $0 [ -g ] [ Test execution spec [ -s number_of_tests_to_skip ]] [-c] [-t]

Options:
       -g	Generate a new test set. Test set generation parameters can be found and tuned inside this script.
       -c	Delete the current test set and results from the $TEST_DIR and $RESULTS_DIR respectively.
       -t	Generate a results report from the results in the $RESULTS_DIR folder.
       -s	If a test execution spec is provided, this allows you to skip any number of tests in the batch.

Test execution spec is defined using the following options:
     -f
        will run the full set of tests (incompatible with -r, -p)
     -r number_of_tests_to_run
     	This will run the specificed number of tests, optionally skipping
	a number of tests from the beginning of the test set.
     -p "file_pattern"
        This will run only the tests matching the provided pattern.

Test file patterns:
     The pattern takes the form of "x y z" (include quotes), where:
       x is one of */linearizable/non_linearizable
       y is * or the number of processes
       z is * or the history length.

     Example: "non_linearizable * 25" represents the set of tests containing
     non-lineairzable histories of length 25, with any number of processes.
EOF
}

set -f # protect file patterns containing * from bash's default expansion behavior
while getopts "gs:cr:p:fth" option
do
    case "${option}"
    in
	c) CLEAN=true;;
	g) GENERATE=true;;
	r) RUN_EXPERIMENTS=true
	   MAX_COUNT=${OPTARG};;
	p) RUN_EXPERIMENTS=true
	   TEST_PAT=( ${OPTARG} );;
	f) RUN_EXPERIMENTS=true;;
	t) TABULATE=true;;
	s) SKIPPING=true
	   NUM_TO_SKIP=${OPTARG};;
	\? | h | "help")
	    usage
	    exit 1;;
    esac
done
set +f #turn expansion back on, now that we have the file pattern

if ((OPTIND == 1))
then
    echo "No options specified. Nothing to do."
    usage
    exit 1
fi

# delete old data
[ $CLEAN ] && rm -rf $TEST_DIR $RESULTS_DIR $TEST_DATA_FILE

# create data folders, if missing
mkdir -p $TEST_DIR
mkdir -p $RESULTS_DIR

# regenerate the testing data, optioanlly only split the data file into individual test files
if [ $GENERATE ]; then
    for p in ${V_PROC_COUNTS[@]}; do
	for hl in ${V_HISTORY_SIZES[@]}; do
	    for (( i=0; i<$HISTORIES_PER_COMBO; i++ )); do
		./vm -f "$TEST_DIR/linearizable-$p-$hl-$i" -p $p -hl $hl -r $RANDOM
	    done
	done
    done

    for p in ${IV_PROC_COUNTS[@]}; do
	for hl in ${IV_HISTORY_SIZES[@]}; do
	    for (( i=0; i<$HISTORIES_PER_COMBO; i++ )); do
		fname="$TEST_DIR/non_linearizable-$p-$hl-$i"
		./vm -f $fname -p $p -hl $hl -r $RANDOM -iv
	    done
	done
    done
fi

if [ $RUN_EXPERIMENTS ]; then
    COUNT=0
    SKIPPED=0

    PAT_LIN=*
    PAT_PROC=*
    PAT_LEN=*

    if [ "${#TEST_PAT[@]}" -gt 0 ]; then
	PAT_LIN=${TEST_PAT[0]}
	PAT_PROC=${TEST_PAT[1]}
	PAT_LEN=${TEST_PAT[2]}
    fi

    FILTER="${PAT_LIN}-${PAT_PROC}-${PAT_LEN}-*"
    for f in $TEST_DIR/$FILTER; do
	if [ -n "$SKIPPING" ] && [ "$SKIPPED" -lt "$NUM_TO_SKIP" ]; then
	    ((SKIPPED++))
	    continue
	fi

	if [ -n "$MAX_COUNT" ]; then
	    [ "$COUNT" -ge "$MAX_COUNT" ] && break # exit loop when exceeding the desired count of experiments
	fi

	if [ -f "$f" ]; then
	    o="${PATTERN/aaa/$f}"
	    echo "generating pml file for test $f"
	    echo "$o" > $FNAME
	    echo "generating pan files"
	    $SPIN -a $FNAME
	    echo "compiling model"
	    $CC -O2 -o t pan.c 2>/dev/null
	    of="$(basename -- $f)"
	    echo "running test"
	    ./t -E > "$RESULTS_DIR/$of.result-us"

	    p=${f#*linearizable-}
	    p=${p%%-*}

	    echo "running scala test (timeout after $SCALA_TIMEOUT seconds)"
            timeout -k 1 "$SCALA_TIMEOUT"s scala -nc -J-Xmx${SCALA_HEAP_SIZE} -cp $LOWE SnapTest.scala $f $p > "$RESULTS_DIR/$of.result-lowe" 2>&1 &
	    wait
	fi
	let COUNT++
    done
    rm test.pml *.pan t
fi

if [ $TABULATE ]; then
    echo "Framwork,Linearizability,#Procs,#Ops,TestID,Time,Memory,Success,Foo" > $TABULATED_FILE
    for f in "$RESULTS_DIR"/*.result-us; do
	fname=$(basename $f .result-us)
	test_config=$(echo $fname | awk -F"-" '{printf "%s,%d,%d,%d",$1,$2,$3,$4; exit}')

	if [ -n "$(grep 'errors: 0' $f)" ]; then
	    linearizable=1
	else
	    linearizable=0
	fi

	single_result=$(awk '/.*total/{mem=$1} /pan: elapsed/{time=$4} END {print time","mem}' $f)
	echo "us,$test_config,$single_result,1,$linearizable" >> $TABULATED_FILE

	sf="$RESULTS_DIR"/$fname.result-lowe
	if [ -s $sf ] && [ -n "$(grep 'solve time' $sf)" ]; then
	    single_result=$(awk '/res/{print $9","$15}' $sf)
	    if [ $linearizable = 1 ]; then
		success=$([ -n "$(grep 'res: 1' $sf)" ] && echo 1 || echo 0)
	    else
		success=$([ -n "$(grep 'res: -2' $sf)" ] && echo 1 || echo 0)
	    fi
	    echo "lowe,$test_config,$single_result,$success,$linearizable" >> $TABULATED_FILE
	else
	    echo "lowe,$test_config,0,0,0,$linearizable" >> $TABULATED_FILE
	fi
    done
fi


#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <errno.h>

#define private static

const int32_t DEFAULT_P = 3;
const uint32_t P_i = 0;
const uint32_t P_j = 1;
const uint64_t OUT_SIZE = 4*1024*1024*15; // 60MB is enough for a single history containing ~4 Million actions

typedef enum {
  None,

  START_ACTIONS_B,
  UpdateStart,
  ScanStart,
  START_ACTIONS_E,

  // Auxiliary actions that can only be generated by start actions
  UpdateWrite,
  ScanRead,

  // End actions that can only be generated by auxiliary actions
  UpdateEnd,
  ScanEnd,
} ActionType;

typedef struct {
  ActionType type;
  int16_t v;
  int8_t vs[2];
} Action;

typedef struct {
  int32_t p;
  int32_t fd;
  void* out_buffer;
  char* next_write;
  int16_t v[2];
  Action tq[];
} VM;


// Start up the VM and the output file
// We use mmap for speed. This makes no difference for short histories, but becomes noticeable for longer histories.
private VM* init_vm(int32_t p, const char* map_file) {
  VM* vm = (VM*) calloc(1, sizeof(VM) + p*sizeof(Action));

  vm->fd = open(map_file, O_RDWR|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
  if (vm->fd < 0) {
    printf("Failed to open file %s\n", map_file);
    perror("The error reported");
    exit(errno);
  }
    
  if(ftruncate(vm->fd, OUT_SIZE) < 0) {
    printf("Failed to resize file %s to %ld bytes\n", map_file, OUT_SIZE);
    perror("The error reported");
    close(vm->fd);
    remove(map_file);
    exit(errno);
  }

  void* out_buffer = mmap(NULL, OUT_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_FILE , vm->fd, 0);
  if (out_buffer == MAP_FAILED) {
    printf("Failed to memory map file %s with size %ld\n", map_file, OUT_SIZE);
    perror("The error reported");
    close(vm->fd);
    remove(map_file);
    exit(errno);
  }

  vm->p = p;
  vm->out_buffer = out_buffer;
  vm->next_write = (char*) out_buffer;

  return vm;
}

// Clean up before shutting down
// Close the mmap, and truncate the output file to its actual size
private void kill_vm(VM* vm) {
  int32_t final_size = vm->next_write - (char *)vm->out_buffer;
  if (ftruncate(vm->fd, final_size) < 0) {
    printf("Failed to compact output file to the final %d bytes. Output file will remain %ld bytes.\n", final_size, OUT_SIZE);
    perror("The error reported");
  }
  munmap(vm->out_buffer, final_size);
  close(vm->fd);
  free(vm);
}

// The main function of the Atomic Snapshot VM.
// The VM logs the simple history as it executes it.
// The VM executes two types of actions: Update actions and Scan actions.
// Only P_i and P_j may write 1 to their segments.
//
// Each operation is made up of three execution steps in the VM:
// 1. The invocation step - no actual work is done here, except for the invocation being logged
// 2. The linearization point step - all the work of the operation happens in this step, fully atomically.
// 3. The response step - no actual work is done here, except for the response being logged.
//
// If a scan response is executed whith is_bogus == true, values logged for the scan response
// are randomized.
private ActionType execute_thread(VM* vm, int32_t tid, bool is_bogus) {
  Action* a = &(vm->tq[tid]);
  ActionType action_to_execute = a->type;

  switch (action_to_execute) {
  case None:
    a->type = (ActionType)((random() % (START_ACTIONS_E - START_ACTIONS_B - 1)) + START_ACTIONS_B + 1);
    return execute_thread(vm, tid, is_bogus);
  case UpdateStart:
    a->type = UpdateWrite;
    if ((tid == P_i || tid == P_j) && (0 == a->v)) {
      a->v = random() % 2;
    }
    vm->next_write += sprintf(vm->next_write, "startUpdate!%d,%d;", tid, a->v);
    break;
  case UpdateWrite:
    a->type = UpdateEnd;
    if (P_i == tid || P_j == tid) {
      vm->v[tid] = a->v;
    }
    break;
  case UpdateEnd:
    a->type = None;
    vm->next_write += sprintf(vm->next_write, "endUpdate!%d,%d;", tid, a->v);
    break;
  case ScanStart:
    a->type = ScanRead;
    vm->next_write += sprintf(vm->next_write, "startScan!%d;", tid);
    break;
  case ScanRead:
    a->type = ScanEnd;
    a->vs[0] = vm->v[0];
    a->vs[1] = vm->v[1];
    break;
  case ScanEnd:
    a->type = None;
    if (is_bogus) {
      a->vs[0] = random() % 2;
      a->vs[1] = random() % 2;
    }
    vm->next_write += sprintf(vm->next_write, "endScan!%d,%d,%d;", tid, a->vs[0], a->vs[1]);
    break;
  default:
    printf("This shouldn't happen\n");
  }

  return action_to_execute;
}

// A convenience function to execute threads with no linearizability violations
private ActionType execute_thread(VM* vm, int32_t tid) {
  return execute_thread(vm, tid, false);
}

// This defines the number of operations to randomize at the end of
// a linearizable history in order to complete a non-linearizable history
#define BOGUS_LENGTH 10

int main (int argc, char** argv) {
  int32_t p = DEFAULT_P;
  const char* map_file = "out.txt";
  int32_t r = 42;
  int32_t history_length = 100;
  int32_t bogus_length = 0;
  bool invalid_histories = false;
  
  for (int i=0; i < argc; i++) {
    if (0 == strncmp(argv[i], "-p", 2)) {
      p = strtol(argv[++i], NULL, 10);
    } else if (0 == strncmp(argv[i], "-f", 2)) {
      map_file = argv[++i];
    } else if (0 == strncmp(argv[i], "-r", 2)) {
      r = strtol(argv[++i], NULL, 10);
    } else if (0 == strncmp(argv[i], "-hl", 2)) {
      history_length = strtol(argv[++i], NULL, 10);
    } else if (0 == strncmp(argv[i], "-iv", 2)) {
      invalid_histories = true;
    }
  }

  printf("Using %d as the random seed.\n", r);
  printf("Generating history for %d threads.\n", p);
  printf("History length being generated is %d.\n", history_length);
  printf("Output file is %s.\n", map_file);
  if (invalid_histories) {
    printf("Attempting to generate non-linearizable history.\n");
    history_length -= BOGUS_LENGTH;
    bogus_length = BOGUS_LENGTH;
  }

  srandom(r);

  VM* vm = init_vm(p, map_file);

  // history length is number of hig-level operations required.
  for (int i=0; i < history_length; ) {
    int32_t tid = random() % p;
    ActionType at = execute_thread(vm, tid);

    if ((START_ACTIONS_B < at) && (at < START_ACTIONS_E)) {
      i++;
    }
  }

  // Attempt to generate a randomly-invalid history by adding some bogus high-level operations.
  // Bogus scan operations return random values instead of the values in the registers
  for (int i=0; i < bogus_length; ) {
    int32_t tid = random() % p;
    ActionType at = execute_thread(vm, tid, true);

    if ((START_ACTIONS_B < at) && (at < START_ACTIONS_E)) {
      i++;
    }
  }
  
  // complete incomplete high-level operations.
  for (int i=0; i < p; i++) {
    while (vm->tq[i].type != None) {
      printf("Completeing partial operation for thread %d (next action should be %d)\n", i, vm->tq[i].type);
      execute_thread(vm, i);
    }
  }
  
  printf("Done. Sutting down...\n");
  kill_vm(vm);
  
  return 0;
}
